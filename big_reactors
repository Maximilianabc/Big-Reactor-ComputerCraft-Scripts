local mon, turbine

local dataItems = {
	"Speed",
	"Production",
	"Steam",
	"Water",
	"Consumption",
	"Engaged"
}
local dataColors = {
	colors.pink,
	colors.lime,
	colors.lightGray,
	colors.lightBlue,
	colors.orange,
	colors.magenta
}

local turbine_data = data.Data:new(nil, "Big Reactor Turbine "..gps.getPosition(), {}, dataItems, dataColors)
local function toggleEngage()
	turbine.setInductorEngaged(not utils.toBoolean(turbine_data.content["Engaged"]))
end

local engageButton = buttons.Button:new(nil, "Engage", "Toggle Engage", toggleEngage)
engageButton:setPosition(1, #dataItems + 4, 10, 3)
engageButton:setColor(colors.black, colors.white)

local turbine_buttons = { engageButton }

local function updateAsync()
	while true do
		turbine_data:setContent({
			["Speed"] = string.format("%f %s", utils.round(turbine.getRotorSpeed(), 2), "RPM"),
			["Production"] = string.format("%f %s", utils.round(turbine.getEnergyProducedLastTick(), 2), "RF/t"),
			["Steam"] = string.format("%d %s", turbine.getInputAmount(), "mB"),
			["Water"] = string.format("%d %s", turbine.getOutputAmount(), "mB"),
			["Consumption"] = string.format("%d %s", turbine.getFluidFlowRate(), "mB/t"),
			["Engaged"] = tostring(turbine.getInductorEngaged())
		})
		turbine_data:output(mon)
		sleep(0.25)
	end
end

local function touchAsync()
	while true do
		local event, peripheral_name, c, r = os.pullEvent("monitor_touch")
		local clicked = buttons.getClicked(turbine_buttons, c, r)
		if (clicked ~= nil) then
			clicked:onClick()
		end
		sleep(0.25)
	end
end

local function keyboardAsync()
	while true do
		local event, key = os.pullEvent("key_up")
		if key == keys.x then
			return
		end
	end
end

function startTurbine()
	mon = peripheral.waitForConnection("monitor")
	mon.clear()
	turbine = peripheral.waitForConnection("BigReactors-Turbine") 
	
	for _, b in pairs(turbine_buttons) do 
		b:display(mon)
	end

	print("Press X to terminate...")
	parallel.waitForAny(updateAsync, touchAsync, keyboardAsync)
	print ("Terminated!")
end
